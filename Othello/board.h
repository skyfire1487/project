#ifndef BOARD_H
#define BOARD_H
#include <iostream>
#include <string>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <ctime>
#include <random>
using namespace std;

class Board {
public:
    int getUnoccupied();// 取得變數unoccupied(盤面上還沒被占據的點的總數)。
    int getStill(); // 取得變數still(連續幾回合玩家無法行動)。
    bool getEarly(); // 看有沒有提早結束遊戲。
    void PrintBoard(); // 印出盤面。
    void updateWeight(int); // 隨盤面更新權重表。
    void Path(int, int); // 計算每個位置的路徑。
    void PrintPath(); // 印出位置路徑。
    void PrintFliptable(); // 印出翻轉次數表。
    void Legal(int, bool[13][13], set<pair<int, int>>[13][13]); // 查看合法走步位置，順便看玩家場上有幾個棋子、有幾個點還沒被佔據。
    void PrintLegal(bool[13][13]); // 印出合法走步位置。
    void Printflip(set<pair<int, int>>[13][13]); // 印出合法走步位置的翻轉位置。
    void Adjacent(bool[13][13], int); // 如果沒有翻子步的話就算相鄰步的位置。
    void ScoreCount(int, vector<float>&); // 計算三方的分數總合(透過審局函式計算)。
    vector<float> maxn(pair<int, int>, set<pair<int, int>>, int, int, float);
    pair<int, int> judge(int, int*, double*, int&); // 判斷下哪個點的分數比較高，並且下那個點。
    void updateBoard(int, int, int, set<pair<int, int>>);
    void Count(int*); // 計算三方佔據棋格數量。
    int Final(); // 最後算每位玩家的f棋子總數。

private:
    // 盤面值 (每輪更新)。
    int board[13][13] = {
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0, -1},
    {-1, -1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0, -1},
    {-1, -1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0, -1},
    {-1, -1, -1,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1},
    {-1, -1,  0,  0,  0,  0,  1,  2,  0,  0,  0,  0, -1},
    {-1,  0,  0,  0,  0,  3,  0,  3,  0,  0,  0,  0, -1},
    {-1,  0,  0,  0,  0,  2,  1,  0,  0,  0,  0, -1, -1},
    {-1,  0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1},
    {-1,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1},
    {-1,  0,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1},
    {-1,  0,  0,  0,  0,  0,  0, -1, -1, -1, -1, -1, -1},
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1} };
    // 路徑表 (每輪更新)。
    int PathTable[13][13] = { {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
                       {-1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, -1},
                       {-1, -1, -1, -1, -1, 4, 3, 3, 3, 3, 3, 4, -1},
                       {-1, -1, -1, -1, 4, 3, 2, 2, 2, 2, 3, 4, -1},
                       {-1, -1, -1, 4, 3, 2, 1, 1, 1, 2, 3, 4, -1},
                       {-1, -1, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, -1},
                       {-1, 4, 3, 2, 1, 0, 1, 0, 1, 2, 3, 4, -1},
                       {-1, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, -1, -1},
                       {-1, 4, 3, 2, 1, 1, 1, 2, 3, 4, -1, -1, -1},
                       {-1, 4, 3, 2, 2, 2, 2, 3, 4, -1, -1, -1, -1},
                       {-1, 4, 3, 3, 3, 3, 3, 4, -1, -1, -1, -1, -1},
                       {-1, 4, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1},
                       {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1} };
    // 翻轉次數表
    float FlipTable[13][13] = {
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 1, 1.7, 1.8, 1.8, 1.7, 1, 0},
        {0, 0, 0, 0, 0, 1.7, 1.3, 3.7, 1.5, 3.7, 1.3, 1.7, 0},
        {0, 0, 0, 0, 1.8, 3.6, 3.8, 4.6, 4.6, 3.8, 3.7, 1.8, 0},
        {0, 0, 0, 1.8, 1.5, 4.7, 2, 5.7, 2, 4.6, 1.5, 1.8, 0},
        {0, 0, 1.7, 3.7, 4.7, 5.7, 4.8, 5, 5.7, 4.6, 3.6, 1.7, 0},
        {0, 1, 1.3, 3.8, 2, 5.2, 2.2, 5.2, 2, 3.8, 1.3, 1, 0},
        {0, 1.7, 3.7, 4.6, 5.7, 5, 4.9, 5.7, 4.6, 3.7, 1.7, 0, 0},
        {0, 1.8, 1.5, 4.6, 2, 5.7, 2, 4.6, 1.5, 1.8, 0, 0, 0},
        {0, 1.8, 3.7, 3.8, 4.7, 4.6, 3.9, 3.7, 1.8, 0, 0, 0, 0},
        {0, 1.7, 1.3, 3.7, 1.5, 3.7, 1.3, 1.7, 0, 0, 0, 0, 0},
        {0, 1, 1.7, 1.8, 1.8, 1.7, 1, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} };
    float Weight[13][13] = { 0 }; // 權重表。
    pair<int, int> outerCorner[6] = { {1,6}, {1,11}, {6,1}, {6,11}, {11,1}, {11,6} }; // 外圍角落。
    int CorDir[6][2] = { {3,4}, {2,5}, {1,5}, {0,4}, {0,3}, {1,2} }; // 外圍各角落查看方向。
    pair<int, int> innerCorner[7] = { {2,6}, {2,10}, {6,10}, {10,6}, {10,2}, {6,2}, {2,6} }; // 內一層角落。
    int neighborDir[6][3] = { {0,1,2}, {0,1,3}, {1,3,5}, {3,4,5}, {2,4,5}, {0,2,4} }; // 內一層各角落查看方向。
    bool AdjStep = false; // 相鄰步下出來了沒。
    int unoccupied = 85; // 還沒被占據的位置。
    int still = 0; // 不能動的回合，當still = 3時表示三方都不能動，遊戲結束。
    int Node = 0; // 每回合跑的node數。
    int totalNode = 0; // 一場遊戲總共跑的node數。
    int N[4] = { 0, 0, 9, 0 }; // 搜尋深度。
    float Bound = 100; // 預測分數上限(採用相對分數的方式來看)。
    int root = 0; // 該回合的玩家，用來在maxn中紀錄搜尋樹的root。
    bool empty = false; // 看這回合有沒有可以下子的點，沒有下子點的話 empty = true。
    bool early = false; // 如果還沒到終局前盤面就只剩下某一方的子就要提前結束。
    int WinLow[4] = { 0, 32, 28, 30 }; // 各玩家勝利的最低子數要求。
};
#endif